<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Neural Network Demo — Political Affiliation (Synthetic)</title>
  <style>
    body{font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial;max-width:1600px;margin:20px auto;padding:12px 20px;color:#0f1720;background:linear-gradient(180deg,#fbfdff,#f3f8ff)}
    h1{font-size:28px;margin-bottom:6px;color:#05263a}
    h2{color:#063a57}
    .card{background:white;border-radius:12px;padding:16px;margin-top:12px;box-shadow:0 8px 24px rgba(12,37,64,0.06)}
    table{border-collapse:collapse;width:100%;margin-top:12px;background:white}
    th,td{border:1px solid #e6eef7;padding:10px;text-align:left;font-size:15px}
    th{background:#f7fbff;color:#063a57}
    .diagram{width:100%;height:760px;background:#fff;border:1px solid #eef;margin-top:12px;border-radius:8px;padding:6px;overflow:hidden}
    .badge{display:inline-block;padding:4px 8px;border-radius:12px;background:#eef}
    .pred{font-weight:600}
    .ok{color:green}
    .bad{color:red}
    .note{font-size:0.98em;color:#1b2b38}
    pre{background:#f7f7f7;padding:8px;border-radius:4px;overflow:auto}
  </style>
</head>
<body>
  <h1>Neural Network Demo — Political Affiliation (Synthetic)</h1>

  <p class="note">For testing purposes and to show how neural networks might be used in real-life applications, this is an educational demo using fully synthetic people and a simulated, premade model. Do not use for real profiling.</p>

  <h2>What we'll show</h2>
  <ul>
    <li>Synthetic dataset: 100 synthetic people with realistic-sounding attributes</li>
    <li>An explanation of what hidden layers do</li>
    <li>An illustrative network diagram (inputs → hidden layers → outputs)</li>
    <li>Premade simulated predictions and trained-model predictions compared to the actual labels</li>
  </ul>

  <h2>How inputs are used in neural networks</h2>
  <p class="note">Each person is converted into a numeric feature vector. Continuous fields (age, income, population) are scaled or normalized; categorical fields (race, job, religion, stance choices) are encoded as one-hot vectors or small numeric embeddings. Those input features form the vector X that the network consumes: each layer computes weighted sums of its inputs, applies an activation function (e.g. ReLU, sigmoid), and passes results forward. The legend above the diagram maps X1…Xn to the human-readable features.</p>

  <h2>Hidden layers: what they do</h2>
  <p class="note">Hidden layers transform raw input values into progressively more abstract signals. Early layers detect simple combinations (e.g. "pro-guns + high income"), middle layers combine those into broader concepts (e.g. "fiscally conservative"), and later layers mix concepts to produce class logits. Non-linear activations let the model represent complex decision boundaries; during training the network adjusts its weights via backpropagation and gradient descent to minimise a loss (e.g. cross-entropy). The final layer converts logits into probabilities (softmax) and the top probability yields the predicted class.</p>

  <h2>Illustrative network architecture</h2>
  <div id="accuracy" style="font-weight:700;margin-bottom:8px">Accuracy: —</div>
  <div id="error" style="color:#a00;font-weight:700;margin-bottom:8px"></div>
  <div id="testAccuracy" style="font-weight:600;margin-bottom:8px;color:#333"></div>
  <div class="diagram card">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
      <div style="font-size:13px;color:#083462;font-weight:700">Inputs legend</div>
      <button id="toggleLegend" style="background:#e6f2ff;border:1px solid #cfe8ff;padding:6px 10px;border-radius:8px;color:#053a63;cursor:pointer">Show inputs (X1…X18)</button>
    </div>
    <div id="inputLegend" style="display:none;max-height:140px;overflow:auto;padding:8px 10px;margin-bottom:8px;border-radius:8px;background:#fbfdff;border:1px solid #eef;">
      <!-- populated by script: X1: Age, X2: Income ... -->
    </div>
    <!-- Larger, styled SVG showing 10 inputs, 3 hidden layers (8,6,4), 6 outputs -->
    <svg id="networkSvg" viewBox="0 0 2000 760" preserveAspectRatio="xMidYMid meet" style="width:100%;height:100%">
      <defs>
        <linearGradient id="nodeGrad" x1="0" x2="1">
          <stop offset="0%" stop-color="#e6f2ff" />
          <stop offset="100%" stop-color="#cfe8ff" />
        </linearGradient>
        <filter id="shadow" x="-50%" y="-50%" width="200%" height="200%">
          <feDropShadow dx="0" dy="2" stdDeviation="4" flood-color="#000" flood-opacity="0.15" />
        </filter>
      </defs>
      <!-- background panel covering full diagram -->
      <rect x="6" y="6" width="1988" height="748" rx="12" fill="#fbfdff" stroke="#eef3fb"></rect>
      <!-- draw nodes via JS after load -->
    </svg>
  </div>

  <h2 id="dataHeading">Dataset — showing 10 of 50 synthetic people</h2>
  <div style="display:flex;gap:12px;align-items:center;margin-top:6px">
    <label for="showCount">Show:</label>
    <select id="showCount">
      <option value="10">10</option>
      <option value="25">25</option>
      <option value="50">50</option>
      <option value="100">100</option>
    </select>
  </div>
  <div style="overflow:auto;margin-top:8px">
  <table id="peopleTable">
    <thead>
      <tr>
        <th>Name</th>
        <th>Gender</th>
        <th>Age</th>
        <th>Income (USD)</th>
        <th>Disability (0/1)</th>
        <th>Guns stance (pro/neutral/anti)</th>
        <th>Abortion stance (pro/neutral/anti)</th>
        <th>City population</th>
        <th>Race</th>
        <th>Job type</th>
        <th>Education level</th>
        <th>Religion</th>
        <th>Support universal healthcare?</th>
        <th>Support free college?</th>
        <th>Support billionaires?</th>
        <th>Support government nationalization of large companies/banks/utilities?</th>
        <th>Support guaranteed jobs?</th>
        <th>Support eviction ban?</th>
        <th>Support breaking banks?</th>
        <th>Actual affiliation</th>
        <th>Predicted affiliation</th>
      </tr>
    </thead>
    <tbody>
    </tbody>
  </table>
  </div>

  <div class="card" style="margin-top:12px;padding:12px" id="manualInputCard">
    <button id="openManualBtn" style="background:#0b6fb5;color:#fff;border:none;padding:8px 12px;border-radius:8px;cursor:pointer">Add manual input</button>
    <div id="manualForm" style="display:none;margin-top:12px">
      <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;align-items:center">
        <label>Name<input id="m_name" type="text" placeholder="Optional" style="width:100%"></label>
        <label>Gender<select id="m_gender"><option>Male</option><option>Female</option><option>Other</option></select></label>
        <label>Age<input id="m_age" type="number" min="0" max="120" value="30" style="width:100%"></label>
        <label>Income<input id="m_income" type="number" min="0" value="40000" style="width:100%"></label>
        <label>Disability<select id="m_disability"><option value="0">0</option><option value="1">1</option></select></label>
        <label>City population<input id="m_city_pop" type="number" min="0" value="50000" style="width:100%"></label>
        <label>Guns stance<select id="m_guns"><option value="pro">pro</option><option value="neutral">neutral</option><option value="anti">anti</option></select></label>
        <label>Abortion stance<select id="m_abortion"><option value="pro">pro</option><option value="neutral">neutral</option><option value="anti">anti</option></select></label>
        <label>Race<select id="m_race"><option>White</option><option>Hispanic</option><option>Black</option><option>Asian</option><option>Other</option></select></label>
        <label>Job type<select id="m_job"><option value="white">white</option><option value="blue">blue</option><option value="other">other</option></select></label>
        <label>Education<select id="m_education"><option value="highschool">highschool</option><option value="some_college">some_college</option><option value="college">college</option><option value="masters">masters</option><option value="postgrad">postgrad</option></select></label>
        <label>Religion<select id="m_religion"><option>Christian</option><option>Atheist</option><option>Jewish</option><option>Muslim</option><option>Hindu</option><option>Other</option></select></label>
        <label>Support universal healthcare?<select id="m_uh"><option value="pro">pro</option><option value="against">against</option></select></label>
        <label>Support free college?<select id="m_fc"><option value="pro">pro</option><option value="against">against</option></select></label>
        <label>Support billionaires?<select id="m_bill"><option value="pro">pro</option><option value="against">against</option></select></label>
        <label>Support government nationalization of large companies/banks/utilities?<select id="m_nationalize"><option value="yes">yes</option><option value="no">no</option></select></label>
        <label>Support guaranteed jobs?<select id="m_guaranteed_job"><option value="yes">yes</option><option value="no">no</option></select></label>
        <label>Support eviction ban?<select id="m_eviction_ban"><option value="yes">yes</option><option value="no">no</option></select></label>
        <label>Support breaking banks?<select id="m_break_banks"><option value="yes">yes</option><option value="no">no</option></select></label>
      </div>
      <div style="margin-top:12px;display:flex;gap:8px">
        <button id="m_submit" style="background:#0b6fb5;color:#fff;border:none;padding:8px 12px;border-radius:8px;cursor:pointer">Run through network</button>
        <button id="m_cancel" style="background:#eee;border:1px solid #ddd;padding:8px 12px;border-radius:8px;cursor:pointer">Cancel</button>
      </div>
      <div id="m_result" style="margin-top:10px;font-weight:700"></div>
    </div>
  </div>

  

  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.8.0/dist/tf.min.js"></script>
  <script>
    // Global error handlers to show runtime problems on the page (helps debugging)
    window.addEventListener('error', function(ev){
      const err = document.getElementById('error');
      if(err) err.textContent = 'Error: ' + (ev.error && ev.error.message ? ev.error.message : ev.message || ev.filename || 'Unknown');
      console.error(ev.error || ev);
    });
    window.addEventListener('unhandledrejection', function(ev){
      const err = document.getElementById('error');
      if(err) err.textContent = 'Unhandled promise rejection: ' + (ev.reason && ev.reason.message ? ev.reason.message : String(ev.reason));
      console.error(ev.reason);
    });

    // Classes
    const CLASSES = ['Democrat','Republican','Libertarian','Anarchist','Socialist'];

    // Helper maps (moved early so other code can use them safely)
    const gunsMap = {pro:1, neutral:0, anti:-1};
    const abortionMap = {pro:1, neutral:0, anti:-1};
    const raceMap = {White:0.3, Asian:0.1, Hispanic:0.0, Black:-0.1, Other:0.0};
    const jobMap = {white:0.2, blue:-0.1, other:0.0};
    const religionMap = {Christian:0.4, Muslim:0.1, Hindu:0.1, Jewish:0.1, Atheist:-0.3, Other:0.0};
    const eduMap = {none:0, elementary:1, middle:2, highschool:3, some_college:4, college:5, masters:6, postgrad:7};
    const uhMap = {pro:1, against:-1};
    const fcMap = {pro:1, against:-1};
    const billMap = {pro:1, against:-1};

    // US-like race priors (approximate, for synthetic data realism)
    const RACE_PRIOR = { White:0.61, Hispanic:0.18, Black:0.12, Asian:0.06, Other:0.03 };

    // richer first/last name pools to create many more unique combinations
    const FIRST_NAMES_BY_RACE = {
      White: {
        female: ['Emma','Olivia','Ava','Sophia','Isabella','Mia','Charlotte','Amelia','Harper','Evelyn','Abigail','Emily'],
        male: ['Liam','Noah','William','James','Benjamin','Lucas','Henry','Alexander','Michael','Daniel','Matthew','Jackson'],
        other: ['Taylor','Alex','Jordan','Casey']
      },
      Hispanic: {
        female: ['Sofia','Isabella','Camila','Valentina','Lucia','Gabriela','Mariana','Ana'],
        male: ['Mateo','Sebastian','Diego','Jose','Luis','Carlos','Angel','Juan'],
        other: ['Alex','Cruz']
      },
      Black: {
        female: ['Aaliyah','Imani','Nia','Zoe','Ariana','Brielle','Keisha','Jada'],
        male: ['Malik','Jalen','Elijah','Darnell','Trevon','DeAndre','Marquis','Kendrick'],
        other: ['Taylor','Jordan']
      },
      Asian: {
        female: ['Maya','Sofia','Asha','Isabella','Li','Mei','Yuna','Hana'],
        male: ['Arjun','Liam','Ethan','Kai','Hiro','Min','Jun','Kenji'],
        other: ['Alex','Sam']
      },
      Other: {
        female: ['Jordan','Casey','Morgan','Riley'],
        male: ['Alex','River','Skyler','Rowan'],
        other: ['Avery']
      }
    };
    const LAST_NAMES_BY_RACE = {
      White: ['Johnson','Miller','Wilson','Taylor','Thomas','White','Brown','Davis','Moore','Anderson','Jackson','Harris','Martin','Thompson'],
      Hispanic: ['Garcia','Rodriguez','Hernandez','Perez','Torres','Martinez','Lopez','Gonzalez','Ramirez','Sanchez'],
      Black: ['Robinson','Brooks','Young','Scott','Walker','Harris','King','Green','Carter','Parker'],
      Asian: ['Patel','Chen','Kumar','Kim','Singh','Nguyen','Lee','Wong','Park','Yamamoto'],
      Other: ['Rivera','Morgan','Lee','Brooks','Reed','Bailey']
    };
    const usedNames = new Set();

    // input labels used in the network diagram and legend (X1..Xn)
    const INPUT_LABELS = ['Age','Income (USD)','Disability','Guns stance','Abortion stance','City population','Race','Job type','Education level','Religion','Support universal healthcare?','Support free college?','Support billionaires?','Support nationalization? (favor public ownership of major industries/utilities)','Support guaranteed jobs?','Support eviction ban?','Support breaking banks?','Gender'];

    // gender map for feature encoding (global so manual input can use it)
    const GENDER_MAP = { Male:0.5, Female:-0.5, Other:0 };

    // global feature builder used by training and manual inputs
    function personToFeatures(p){
      return [
        p.age/100,
        p.income/100000,
        p.disability?1:0,
        gunsMap[p.guns]||0,
        abortionMap[p.abortion]||0,
        Math.log10(Math.max(1,p.city_pop))/6.5,
        raceMap[p.race]||0,
        jobMap[p.job]||0,
        (eduMap[p.education]!==undefined?eduMap[p.education]/7:0),
        religionMap[p.religion]||0,
        uhMap[p.universal_healthcare]||0,
        fcMap[p.free_college]||0,
        billMap[p.billionaires]||0,
        (p.nationalize==='yes' ? 1 : 0),
        (p.guaranteed_job==='yes' ? 1 : 0),
        (p.eviction_ban==='yes' ? 1 : 0),
        (p.break_banks==='yes' ? 1 : 0),
        GENDER_MAP[p.gender]||0
      ];
    }

    // baseline religion priors (approximate US-like mix)
    const RELIGION_BASE = { Christian:0.63, Atheist:0.22, Jewish:0.02, Muslim:0.01, Hindu:0.01, Other:0.11 };

    // pick with weighted probs helper
    function pickWeighted(items, weights){
      let r = Math.random(); let cum = 0;
      for(let i=0;i<items.length;i++){ cum += weights[i]; if(r < cum) return items[i]; }
      return items[items.length-1];
    }

    // sample a race using the baseline priors and a small class modifier
    function sampleRaceForClass(cls){
      // start from base probs array in same order as earlier usage
      const keys = ['White','Asian','Hispanic','Black','Other'];
      const base = keys.map(k=>RACE_PRIOR[k]||0.0);
      // small class-based multipliers to reflect turnout/demographic skews
      const multipliers = { Democrat:[0.95,1.2,1.15,1.1,1.0], Republican:[1.15,0.9,0.85,0.85,1.0], Libertarian:[1.0,1.0,0.95,0.9,1.0], Anarchist:[0.9,1.1,1.05,0.95,1.0], Socialist:[0.9,1.1,1.2,1.0,1.0], Independent:[1.0,1.0,1.0,1.0,1.0] };
      const m = multipliers[cls] || multipliers['Independent'];
      const adj = base.map((v,i)=> v * m[i]);
      const s = adj.reduce((a,b)=>a+b,0);
      const probs = adj.map(v=> v / s);
      return pickWeighted(keys, probs);
    }

    // We'll generate a synthetic dataset programmatically so labels follow a consistent
    // ground-truth weight matrix. This lets the demo reach high accuracy on synthetic data.

    // ground-truth weight matrix (used to assign 'actual' labels)
    const W_truth = {
      // feature order: age, income, disability, guns, abortion, city_pop, race, job, edu, religion, uh, fc, bill, nationalize, guaranteed_job, eviction_ban, break_banks
      Democrat:    [ -0.3, -0.2, 0.0, -0.8, 0.9,  0.6, -0.2, -0.1, 0.2, -0.4, 0.6, 0.5, -0.6, -0.2, -0.1, -0.05, -0.1],
      Republican:  [  0.4,  0.6, 0.0,  0.9, -0.8, -0.3, 0.3,  0.2, 0.0, 0.5, -0.6, -0.5, 0.7, -0.6, -0.4, -0.5, -0.6],
      Libertarian: [  0.1,  0.4, 0.0,  0.8,  0.0, -0.2, 0.0,  0.1, 0.3, -0.4, -0.4, -0.3, 0.5, -0.5, -0.4, -0.3, -0.4],
      Anarchist:   [ -0.5, -0.6, 0.0, -0.9,  0.7,  0.8, -0.2, -0.2, -0.1, -0.6, 0.4, 0.6, -0.8, -0.1, 0.1, 0.3, 0.2],
      Socialist:   [ -0.2, -0.7, 0.0, -0.8,  0.9,  0.7, 0.1, -0.1, 0.4, -0.5, 0.9, 0.9, -0.9, 1.0, 0.9, 0.8, 0.95]
    };
    const B_truth = {Democrat:0.0, Republican:0.1, Libertarian:-0.1, Anarchist:-0.2, Socialist:0.05};

    // helper: create random person
    function randChoice(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
    function randInt(a,b){ return a + Math.floor(Math.random()*(b-a+1)); }

    // Sample realistic people conditioned on class so data is believable and correlates
    // with the ground-truth weight matrix.
    function makePersonForClass(cls, i){
      // choose race first using base priors then class skews
      const race = sampleRaceForClass(cls);
      // small helper used throughout this function
      const pick = (arr, probs) => {
        if(!probs) return arr[Math.floor(Math.random()*arr.length)];
        let r = Math.random(); let cum = 0;
        for(let j=0;j<arr.length;j++){ cum += probs[j]; if(r < cum) return arr[j]; }
        return arr[arr.length-1];
      };
      // gender: simple 3-way with light class skews (pick gender first, then name)
      let gender;
      if(cls === 'Democrat') gender = pick(['Female','Male','Other'], [0.52,0.46,0.02]);
      else if(cls === 'Republican') gender = pick(['Male','Female','Other'], [0.5,0.48,0.02]);
      else if(cls === 'Socialist') gender = pick(['Female','Male','Other'], [0.56,0.42,0.02]);
      else gender = pick(['Male','Female','Other'], [0.5,0.48,0.02]);
      // build a more unique name by combining first + last pools, avoid repeats
      const genderKey = (gender||'Other').toLowerCase();
      const firstPool = (FIRST_NAMES_BY_RACE[race] && FIRST_NAMES_BY_RACE[race][genderKey] && FIRST_NAMES_BY_RACE[race][genderKey].length>0) ? FIRST_NAMES_BY_RACE[race][genderKey] : (FIRST_NAMES_BY_RACE[race] ? [].concat(FIRST_NAMES_BY_RACE[race].female||[], FIRST_NAMES_BY_RACE[race].male||[], FIRST_NAMES_BY_RACE[race].other||[]) : [].concat(FIRST_NAMES_BY_RACE.White.female, FIRST_NAMES_BY_RACE.White.male));
      const lastPool = LAST_NAMES_BY_RACE[race] || LAST_NAMES_BY_RACE.White;
      let name = '';
      let tries = 0;
      do{
        const first = randChoice(firstPool);
        const last = randChoice(lastPool);
        name = first + ' ' + last;
        tries++;
      } while(usedNames.has(name) && tries < 8);
      usedNames.add(name);
      // small helper used throughout this function
      let age, income, disability, guns, abortion, city_pop, job, education, religion, universal_healthcare, free_college, billionaires;

      // sample religion influenced by race and class (keeps Muslim/Jewish small overall)
      function sampleReligion(race, cls){
        const keys = ['Christian','Atheist','Jewish','Muslim','Hindu','Other'];
        // start from baseline
        const base = keys.map(k=> RELIGION_BASE[k] || 0);
        // race modifiers
        const raceMult = {
          White:  [1.05,1.0,1.6,0.8,1.0,1.0],
          Hispanic:[1.15,0.6,0.6,0.6,0.8,1.0],
          Black:  [1.2,0.6,0.5,0.7,0.8,1.0],
          Asian:  [0.85,1.0,0.6,1.2,1.6,1.0],
          Other:  [1.0,1.0,1.0,1.0,1.0,1.0]
        };
        const classMult = {
          Democrat:   [0.95,1.15,1.1,1.0,1.0,1.0],
          Republican: [1.2,0.5,0.8,0.9,0.9,1.0],
          Libertarian:[1.0,1.1,0.9,1.0,1.0,1.0],
          Anarchist:  [0.6,1.6,0.7,1.0,1.0,1.1],
          Socialist:  [0.7,1.5,0.8,1.0,1.0,1.1],
          Independent:[1.0,1.0,1.0,1.0,1.0,1.0]
        };
        const rm = raceMult[race] || raceMult.Other;
        const cm = classMult[cls] || classMult.Independent;
        const adj = base.map((v,i)=> v * (rm[i] || 1) * (cm[i] || 1));
        const s = adj.reduce((a,b)=>a+b,0) || 1;
        const probs = adj.map(v=> v / s);
        return pickWeighted(keys, probs);
      }

      // sample class-conditional distributions (designed to align with W_truth)
      if(cls === 'Democrat'){
        age = randInt(22,65);
        income = randInt(0,120000);
        disability = Math.random()<0.06?1:0;
        guns = pick(['anti','neutral','pro'], [0.6,0.3,0.1]);
        abortion = pick(['pro','neutral','anti'], [0.7,0.2,0.1]);
        city_pop = pick([10000,50000,120000,250000,500000,900000,1500000,3000000],[0.02,0.05,0.1,0.15,0.25,0.25,0.12,0.06]);
        job = pick(['white','blue','other'], [0.6,0.2,0.2]);
        education = pick(['highschool','some_college','college','masters','postgrad'], [0.1,0.2,0.45,0.15,0.1]);
        religion = sampleReligion(race, cls);
        universal_healthcare = pick(['pro','against'], [0.8,0.2]);
        free_college = pick(['pro','against'], [0.7,0.3]);
        billionaires = pick(['against','pro'], [0.6,0.4]);
        // discriminators (targeted economic-left markers)
        nationalize = pick(['yes','no'], [0.28,0.72]);
        guaranteed_job = pick(['yes','no'], [0.22,0.78]);
        eviction_ban = pick(['yes','no'], [0.35,0.65]);
        break_banks = pick(['yes','no'], [0.4,0.6]);
      } else if(cls === 'Republican'){
        age = randInt(35,82);
        income = randInt(15000,200000);
        disability = Math.random()<0.12?1:0;
        guns = pick(['pro','neutral','anti'], [0.65,0.25,0.1]);
        abortion = pick(['anti','neutral','pro'], [0.6,0.3,0.1]);
        city_pop = pick([8000,20000,50000,120000,250000,500000,900000,1500000],[0.25,0.2,0.15,0.15,0.1,0.08,0.05,0.02]);
        job = pick(['white','blue','other'], [0.55,0.3,0.15]);
        education = pick(['highschool','some_college','college','masters','postgrad'], [0.25,0.3,0.3,0.1,0.05]);
        religion = sampleReligion(race, cls);
        universal_healthcare = pick(['against','pro'], [0.75,0.25]);
        free_college = pick(['against','pro'], [0.8,0.2]);
        billionaires = pick(['pro','against'], [0.72,0.28]);
        nationalize = pick(['yes','no'], [0.03,0.97]);
        guaranteed_job = pick(['yes','no'], [0.02,0.98]);
        eviction_ban = pick(['yes','no'], [0.04,0.96]);
        break_banks = pick(['yes','no'], [0.12,0.88]);
      } else if(cls === 'Socialist'){
        age = randInt(18,40);
        income = randInt(0,50000);
        disability = Math.random()<0.05?1:0;
        guns = pick(['anti','neutral','pro'], [0.75,0.18,0.07]);
        abortion = pick(['pro','neutral','anti'], [0.8,0.15,0.05]);
        city_pop = pick([50000,120000,250000,500000,900000,1500000,3000000],[0.05,0.15,0.25,0.25,0.2,0.08,0.02]);
        job = pick(['white','blue','other'], [0.3,0.25,0.45]);
        education = pick(['highschool','some_college','college','masters'], [0.15,0.35,0.35,0.15]);
        religion = sampleReligion(race, cls);
        universal_healthcare = pick(['pro','against'], [0.92,0.08]);
        free_college = pick(['pro','against'], [0.9,0.1]);
        billionaires = pick(['against','pro'], [0.88,0.12]);
        nationalize = pick(['yes','no'], [0.55,0.45]);
        guaranteed_job = pick(['yes','no'], [0.47,0.53]);
        eviction_ban = pick(['yes','no'], [0.62,0.38]);
        break_banks = pick(['yes','no'], [0.68,0.32]);
      } else if(cls === 'Libertarian'){
        age = randInt(20,50);
        income = randInt(0,120000);
        disability = Math.random()<0.04?1:0;
        guns = pick(['pro','neutral','anti'], [0.6,0.3,0.1]);
        abortion = pick(['neutral','pro','anti'], [0.6,0.25,0.15]);
        city_pop = pick([8000,20000,50000,120000,250000,500000],[0.2,0.25,0.2,0.15,0.12,0.08]);
        job = pick(['white','blue','other'], [0.55,0.25,0.2]);
        education = pick(['highschool','some_college','college','masters'], [0.25,0.4,0.28,0.07]);
        religion = sampleReligion(race, cls);
        universal_healthcare = pick(['against','pro'], [0.7,0.3]);
        free_college = pick(['against','pro'], [0.75,0.25]);
        billionaires = pick(['pro','against'], [0.75,0.25]);
        nationalize = pick(['yes','no'], [0.05,0.95]);
        guaranteed_job = pick(['yes','no'], [0.06,0.94]);
        eviction_ban = pick(['yes','no'], [0.08,0.92]);
        break_banks = pick(['yes','no'], [0.18,0.82]);
      } else if(cls === 'Anarchist'){
        age = randInt(16,28);
        income = randInt(0,40000);
        disability = Math.random()<0.03?1:0;
        guns = pick(['anti','neutral','pro'], [0.7,0.25,0.05]);
        abortion = pick(['pro','neutral','anti'], [0.85,0.1,0.05]);
        city_pop = pick([5000,20000,120000,250000,900000],[0.05,0.15,0.25,0.3,0.25]);
        job = pick(['white','blue','other'], [0.1,0.2,0.7]);
        education = pick(['none','highschool','some_college','college'], [0.2,0.4,0.3,0.1]);
        religion = sampleReligion(race, cls);
        universal_healthcare = pick(['pro','against'], [0.9,0.1]);
        free_college = pick(['pro','against'], [0.9,0.1]);
        billionaires = pick(['against','pro'], [0.95,0.05]);
        nationalize = pick(['yes','no'], [0.78,0.22]);
        guaranteed_job = pick(['yes','no'], [0.65,0.35]);
        eviction_ban = pick(['yes','no'], [0.78,0.22]);
        break_banks = pick(['yes','no'], [0.82,0.18]);
      } else { // Independent / mixed
        age = randInt(22,70);
        income = randInt(0,150000);
        disability = Math.random()<0.08?1:0;
        guns = pick(['pro','neutral','anti'], [0.35,0.3,0.35]);
        abortion = pick(['pro','neutral','anti'], [0.45,0.3,0.25]);
        city_pop = pick([8000,20000,50000,120000,250000,500000,900000],[0.12,0.18,0.2,0.2,0.15,0.1,0.05]);
        job = pick(['white','blue','other'], [0.5,0.25,0.25]);
        education = pick(['highschool','some_college','college','masters','postgrad'], [0.2,0.3,0.35,0.12,0.03]);
        religion = sampleReligion(race, cls);
        universal_healthcare = pick(['pro','against'], [0.55,0.45]);
        free_college = pick(['pro','against'], [0.45,0.55]);
        billionaires = pick(['pro','against'], [0.45,0.55]);
        nationalize = pick(['yes','no'], [0.28,0.72]);
        guaranteed_job = pick(['yes','no'], [0.22,0.78]);
        eviction_ban = pick(['yes','no'], [0.32,0.68]);
        break_banks = pick(['yes','no'], [0.35,0.65]);
      }

      // small chance of very low / zero income across the population to increase realism
      if(Math.random() < 0.03){
        if(Math.random() < 0.6) income = 0; else income = Math.min(income, randInt(0,8000));
      }
      return {name,gender,age,income,disability,guns,abortion,city_pop,race,job,education,religion,universal_healthcare,free_college,billionaires,nationalize,guaranteed_job,eviction_ban,break_banks};
    }

    // generate N synthetic people with class-conditioned sampling
    const people = (function(){
      const arr = [];
      const classes = ['Democrat','Republican','Libertarian','Anarchist','Socialist'];
      const classP = [0.34,0.34,0.08,0.06,0.18]; // priors summing to 1 (no Independent)
      function pickClass(){
        let r = Math.random(); let cum=0; for(let i=0;i<classes.length;i++){cum+=classP[i]; if(r<cum) return classes[i];}
        return classes[classes.length-1];
      }
      for(let i=0;i<100;i++){
        const cls = pickClass();
        const p = makePersonForClass(cls,i);
        p.actual = cls;
        // rule: if the person supports billionaires, they should not be labeled Socialist
        if(p.billionaires === 'pro' && p.actual === 'Socialist'){
          p.actual = 'Democrat';
        }
        arr.push(p);
      }
      return arr;
    })();

      // --- In-browser training (TF.js) ---
      async function trainAndEvaluate(){
        if(typeof tf === 'undefined'){
          console.warn('TF.js not loaded');
          return;
        }
        // use the shared global personToFeatures defined earlier

        const X = people.map(p=> personToFeatures(p));
        const classToIdx = {}; CLASSES.forEach((c,i)=> classToIdx[c]=i);
        const Y = people.map(p=>{
          const arr = new Array(CLASSES.length).fill(0);
          arr[classToIdx[p.actual]] = 1; return arr;
        });

        // shuffle indices
        const idx = Array.from({length: X.length}, (_,i)=>i);
        for(let i=idx.length-1;i>0;i--){ const j = Math.floor(Math.random()*(i+1)); [idx[i],idx[j]]=[idx[j],idx[i]]; }
        const Xs = idx.map(i=>X[i]);
        const Ys = idx.map(i=>Y[i]);

        const split = Math.floor(Xs.length * 0.8);
        const trainX = tf.tensor2d(Xs.slice(0,split));
        const trainY = tf.tensor2d(Ys.slice(0,split));
        const testX = tf.tensor2d(Xs.slice(split));
        const testY = tf.tensor2d(Ys.slice(split));

        const inputDim = X[0].length;
        const model = tf.sequential();
        model.add(tf.layers.dense({units:32, activation:'relu', inputShape:[inputDim]}));
        model.add(tf.layers.dropout({rate:0.2}));
        model.add(tf.layers.dense({units:16, activation:'relu'}));
        model.add(tf.layers.dense({units:CLASSES.length, activation:'softmax'}));
        model.compile({optimizer: tf.train.adam(0.01), loss:'categoricalCrossentropy', metrics:['accuracy']});

        const accEl = document.getElementById('accuracy');
        await model.fit(trainX, trainY, {
          epochs: 60,
          batchSize: 8,
          validationSplit: 0.15,
          callbacks: {
            onEpochEnd: async (epoch, logs) => {
              const trainAcc = (logs.acc||logs.accuracy||0)*100;
              const valAcc = (logs.val_acc||logs.val_accuracy||0)*100;
              if(accEl) accEl.textContent = `Training epoch ${epoch+1}: train ${trainAcc.toFixed(1)}% val ${valAcc.toFixed(1)}%`;
              await tf.nextFrame();
            }
          }
        });

        // keep the trained model available globally for manual predictions
        try{ window.trainedModel = model; window.trainedModelReady = true; }catch(e){ console.warn('Could not expose trained model globally', e); }

        // evaluate on test set
        const evalRes = model.evaluate(testX, testY);
        const testAccTensor = Array.isArray(evalRes) ? evalRes[1] : evalRes;
        const testAcc = (await testAccTensor.data())[0] * 100;

        // predict for all and re-render table with trained predictions
        const allX = tf.tensor2d(X);
        const preds = model.predict(allX).argMax(-1).dataSync();
        const predClasses = Array.from(preds).map(i=> CLASSES[i]);

        // render using the existing renderer which respects `visibleCount`
        renderTableWithPreds(predClasses);
        const testAccEl = document.getElementById('testAccuracy');
        if(testAccEl) testAccEl.textContent = `Trained test accuracy: ${testAcc.toFixed(1)}%`;

        trainX.dispose(); trainY.dispose(); testX.dispose(); testY.dispose(); allX.dispose();
      }


    // Helper maps (kept for compatibility if referenced later)
    // (actual definitions already moved earlier)

    // Simulated scoring function (a premade, interpretable model for demo)
    function simulateModel(person){
      // build numeric feature vector
      const f = [];
      f.push(person.age/100); // normalize roughly
      f.push(person.income/100000);
      f.push(person.disability?1:0);
      f.push(gunsMap[person.guns]||0);
      f.push(abortionMap[person.abortion]||0);
      f.push(Math.log10(Math.max(1, person.city_pop))/6.5); // scaled
      f.push(raceMap[person.race]||0);
      f.push(jobMap[person.job]||0);
      f.push(eduMap[person.education]!==undefined?eduMap[person.education]/7:0);
      f.push(religionMap[person.religion]||0);
      // new policy features
      f.push(uhMap[person.universal_healthcare]||0);
      f.push(fcMap[person.free_college]||0);
      f.push(billMap[person.billionaires]||0);

      // class weights (handcrafted for demo). Each array is weights for one class
      const W = {
        Democrat:    [ -0.3, -0.2, 0.0, -0.8, 0.9,  0.6, -0.2, -0.1, 0.2, -0.4, 0.6, 0.5, -0.6, -0.2, -0.1, -0.05, -0.1],
        Republican:  [  0.4,  0.6, 0.0,  0.9, -0.8, -0.3, 0.3,  0.2, 0.0, 0.5, -0.6, -0.5, 0.7, -0.6, -0.4, -0.5, -0.6],
        Libertarian: [  0.1,  0.4, 0.0,  0.8,  0.0, -0.2, 0.0,  0.1, 0.3, -0.4, -0.4, -0.3, 0.5, -0.5, -0.4, -0.3, -0.4],
        Anarchist:   [ -0.5, -0.6, 0.0, -0.9,  0.7,  0.8, -0.2, -0.2, -0.1, -0.6, 0.4, 0.6, -0.8, -0.1, 0.1, 0.3, 0.2],
        Socialist:   [ -0.2, -0.7, 0.0, -0.8,  0.9,  0.7, 0.1, -0.1, 0.4, -0.5, 0.9, 0.9, -0.9, 1.0, 0.9, 0.8, 0.95]
      };
      const B = {Democrat:0.0, Republican:0.1, Libertarian:-0.1, Anarchist:-0.2, Socialist:0.05};

      // compute raw scores
      const scores = CLASSES.map(c=>{
        const w = W[c];
        let s = B[c];
        for(let i=0;i<w.length;i++) s += w[i]*f[i];
        return s;
      });

      // softmax
      const mx = Math.max(...scores);
      const ex = scores.map(s=>Math.exp(s-mx));
      const sum = ex.reduce((a,b)=>a+b,0);
      const probs = ex.map(e=>e/sum);
      // return top class and distribution
      let bestIdx = 0; for(let i=1;i<probs.length;i++) if(probs[i]>probs[bestIdx]) bestIdx=i;
      return {class:CLASSES[bestIdx], probs};
    }

    // render table helper using provided predicted-classes array
    let currentPreds = null;
    let visibleCount = 10;
    function renderTableWithPreds(preds){
      currentPreds = preds;
      const tbody = document.querySelector('#peopleTable tbody');
      tbody.innerHTML = '';
      let correct = 0;
      const n = Math.min(visibleCount, people.length);
      for(let i=0;i<n;i++){
        const p = people[i];
        const predClass = preds[i];
        if(predClass === p.actual) correct++;
        const tr = document.createElement('tr');
        const cells = [p.name,p.gender,p.age,p.income,p.disability,p.guns,p.abortion,p.city_pop,p.race,p.job,p.education,p.religion,p.universal_healthcare,p.free_college,p.billionaires,p.nationalize,p.guaranteed_job,p.eviction_ban,p.break_banks,p.actual,predClass];
        cells.forEach((c,j)=>{
          const td = document.createElement('td'); td.textContent = c;
          if(j===19){ td.className = (p.actual===predClass)?'ok':''; }
          if(j===20){ td.innerHTML = '<span class="pred">'+predClass+'</span>' + (predClass===p.actual? ' <span class="ok">✓</span>' : ' <span class="bad">✗</span>'); }
          tr.appendChild(td);
        });
        tbody.appendChild(tr);
      }
      const pct = Math.round((correct / n) * 1000) / 10;
      const accEl = document.getElementById('accuracy');
      if(accEl) accEl.textContent = `Accuracy (shown ${n}): ${pct}% (${correct}/${n})`;
      const heading = document.getElementById('dataHeading');
      if(heading) heading.textContent = `Dataset — showing ${n} of ${people.length} synthetic people`;
    }

    // compute initial predictions using the simulated scoring function and render first view
    const initialPreds = people.map(p=> simulateModel(p).class);
    renderTableWithPreds(initialPreds);
    // start in-browser training to improve model and update predictions
    trainAndEvaluate().catch(e=> console.error('Training failed', e));

    // render the input legend (X1..Xn) and wire toggle button
    (function(){
      const legendWrap = document.getElementById('inputLegend');
      const btn = document.getElementById('toggleLegend');
      if(!legendWrap || !btn) return;
      function buildLegend(){
        legendWrap.innerHTML = '';
        const ul = document.createElement('div'); ul.style.display='grid'; ul.style.gridTemplateColumns='repeat(2,1fr)'; ul.style.gap='6px 12px';
        INPUT_LABELS.forEach((lab,i)=>{
          const d = document.createElement('div'); d.style.fontSize='13px'; d.style.color='#063a57'; d.textContent = 'X' + (i+1) + ': ' + lab; ul.appendChild(d);
        });
        legendWrap.appendChild(ul);
      }
      buildLegend();
      btn.addEventListener('click', ()=>{
        if(legendWrap.style.display === 'none' || legendWrap.style.display === ''){
          legendWrap.style.display = 'block'; btn.textContent = 'Hide inputs';
        } else { legendWrap.style.display = 'none'; btn.textContent = 'Show inputs (X1…X18)'; }
      });
    })();

    // show-count selector behavior
    document.getElementById('showCount').addEventListener('change', function(ev){
      visibleCount = parseInt(this.value,10) || 10;
      if(currentPreds) renderTableWithPreds(currentPreds);
    });

    // Manual input UI wiring
    document.getElementById('openManualBtn').addEventListener('click', ()=>{
      const f = document.getElementById('manualForm'); if(!f) return; f.style.display = (f.style.display==='none' || f.style.display==='') ? 'block' : 'none';
    });
    document.getElementById('m_cancel').addEventListener('click', ()=>{ document.getElementById('manualForm').style.display='none'; document.getElementById('m_result').textContent=''; });
    async function getPredictionsForPerson(p){
      // prefer trained model prediction (with confidence); fall back to simulated model
      if(window.trainedModel && window.trainedModelReady){
        try{
          const feats = personToFeatures(p);
          const t = tf.tensor2d([feats]);
          const out = window.trainedModel.predict(t);
          const probs = Array.from((await out.data()));
          const max = Math.max(...probs);
          const idx = probs.indexOf(max);
          const cls = CLASSES[idx];
          out.dispose(); t.dispose();
          return {source:'trained', class:cls, confidence: max};
        }catch(e){ console.warn('trained predict failed', e); }
      }
      // fallback to simulated scoring (returns probs)
      const sim = simulateModel(p);
      const simProbs = sim.probs || [];
      const simMax = simProbs.length? Math.max(...simProbs) : 0;
      const simIdx = simProbs.length? simProbs.indexOf(simMax) : -1;
      const simCls = simIdx>=0? CLASSES[simIdx] : sim.class;
      return {source:'simulated', class: simCls, confidence: simMax};
    }

    document.getElementById('m_submit').addEventListener('click', async ()=>{
      const p = {
        name: document.getElementById('m_name').value || 'Manual Person',
        gender: document.getElementById('m_gender').value,
        age: parseInt(document.getElementById('m_age').value,10)||30,
        income: parseInt(document.getElementById('m_income').value,10)||0,
        disability: document.getElementById('m_disability').value==='1'?1:0,
        city_pop: parseInt(document.getElementById('m_city_pop').value,10)||50000,
        guns: document.getElementById('m_guns').value,
        abortion: document.getElementById('m_abortion').value,
        race: document.getElementById('m_race').value,
        job: document.getElementById('m_job').value,
        education: document.getElementById('m_education').value,
        religion: document.getElementById('m_religion').value,
        universal_healthcare: document.getElementById('m_uh').value,
        free_college: document.getElementById('m_fc').value,
        billionaires: document.getElementById('m_bill').value,
        nationalize: document.getElementById('m_nationalize').value,
        guaranteed_job: document.getElementById('m_guaranteed_job').value,
        eviction_ban: document.getElementById('m_eviction_ban').value,
        break_banks: document.getElementById('m_break_banks').value
      };
      const res = await getPredictionsForPerson(p);
      const outEl = document.getElementById('m_result');
      if(res && res.class){
        const pct = (res.confidence*100).toFixed(1);
        const label = res.class + (res.source === 'trained' ? ' (trained)' : ' (simulated)');
        outEl.textContent = `Prediction: ${label} — confidence ${pct}%`;
      } else {
        outEl.textContent = 'Prediction unavailable';
      }
    });

    // Draw larger, styled SVG diagram programmatically
    (function(){
      const svg = document.querySelector('.diagram svg');
      const width = 2000, height = 760;
      const inputX = 111;
      const h1X = 578, h2X = 1089, h3X = 1511, outX = 1867;

      const inputCount = 18; const h1=10,h2=8,h3=5,out = CLASSES.length;
      const nodeR = 16;
      const marginTop = 18, marginBottom = 40;
      function addCircle(x,y,label,opts={}){
        const g = document.createElementNS('http://www.w3.org/2000/svg','g');
        const c = document.createElementNS('http://www.w3.org/2000/svg','circle');
        c.setAttribute('cx',x); c.setAttribute('cy',y);
        const r = opts.large? (nodeR+6) : (opts.small?10:nodeR);
        c.setAttribute('r',r);
        c.setAttribute('fill','url(#nodeGrad)'); c.setAttribute('stroke','#2b6ea8'); c.setAttribute('stroke-width','1.6'); c.setAttribute('filter','url(#shadow)');
        const t = document.createElementNS('http://www.w3.org/2000/svg','text');
        // place label left or right with padding based on node radius
        if(opts.labelLeft){
          const pad = opts.leftPad!==undefined?opts.leftPad:28;
          t.setAttribute('x', x - (r + pad)); t.setAttribute('y', y + 6);
          t.setAttribute('font-size','12'); t.setAttribute('fill','#083462'); t.setAttribute('font-weight','700'); t.setAttribute('text-anchor','end');
        } else {
          const pad = opts.rightPad!==undefined?opts.rightPad:18;
          t.setAttribute('x', x + (r + pad)); t.setAttribute('y', y + 6);
          t.setAttribute('font-size','12'); t.setAttribute('fill','#083462'); t.setAttribute('font-weight','700');
        }
        t.textContent = label;
        g.appendChild(c); g.appendChild(t);
        if(opts.small) c.setAttribute('r',10);
        svg.appendChild(g);
      }
      function addBias(x,y,label){
        const g = document.createElementNS('http://www.w3.org/2000/svg','g');
        const c = document.createElementNS('http://www.w3.org/2000/svg','circle');
        c.setAttribute('cx',x); c.setAttribute('cy',y); c.setAttribute('r',8); c.setAttribute('fill','#ffdca8'); c.setAttribute('stroke','#b36b00'); c.setAttribute('stroke-width','1'); c.setAttribute('filter','url(#shadow)');
        const v = document.createElementNS('http://www.w3.org/2000/svg','text');
        v.setAttribute('x',x-4); v.setAttribute('y',y+5); v.setAttribute('font-size','12'); v.setAttribute('fill','#5a3300'); v.setAttribute('font-weight','700'); v.textContent = '1';
        const t = document.createElementNS('http://www.w3.org/2000/svg','text');
        t.setAttribute('x',x+14); t.setAttribute('y',y+5); t.setAttribute('font-size','12'); t.setAttribute('fill','#5a3300'); t.textContent = label;
        g.appendChild(c); g.appendChild(v); g.appendChild(t);
        svg.appendChild(g);
        return {x,y};
      }
      function addLine(x1,y1,x2,y2,opts={}){
        const l = document.createElementNS('http://www.w3.org/2000/svg','line');
        l.setAttribute('x1',x1); l.setAttribute('y1',y1); l.setAttribute('x2',x2); l.setAttribute('y2',y2);
        l.setAttribute('stroke','#5b7c99'); l.setAttribute('stroke-width',opts.thick?2:1); l.setAttribute('stroke-opacity',0.55);
        if(opts.dashed) l.setAttribute('stroke-dasharray','6 5');
        svg.appendChild(l);
      }

      // layer title helper
      function addLayerLabel(x,y,text,opts={}){
        const tt = document.createElementNS('http://www.w3.org/2000/svg','text');
        tt.setAttribute('x',x); tt.setAttribute('y',y); tt.setAttribute('font-size','14'); tt.setAttribute('fill','#0b324d'); tt.setAttribute('font-weight','800');
        if(opts.center) tt.setAttribute('text-anchor','middle');
        if(opts.xOffset) tt.setAttribute('x', x + opts.xOffset);
        tt.textContent = text;
        svg.appendChild(tt);
      }

      // positions with increased vertical spacing
      const avail = height - marginTop - marginBottom;
      function linspace(n, topOffset=0, bottomOffset=0){
        const top = marginTop + topOffset;
        const bottom = height - marginBottom - bottomOffset;
        if(n===1) return [(top+bottom)/2];
        const step = (bottom-top)/(n-1);
        return Array.from({length:n},(_,i)=> Math.round(top + i*step));
      }

      const inputYs = linspace(inputCount, 10, 10);
      inputYs.forEach((y,i)=> addCircle(inputX,y,'X'+(i+1),{labelLeft:true,leftPad:36}));
      const h1Ys = linspace(h1, 18, 18); h1Ys.forEach(y=> addCircle(h1X,y,''));
      const h2Ys = linspace(h2, 36, 36); h2Ys.forEach(y=> addCircle(h2X,y,''));
      const h3Ys = linspace(h3, 54, 54); h3Ys.forEach(y=> addCircle(h3X,y,''));
      const outYs = linspace(out, 30, 30); outYs.forEach((y,i)=> addCircle(outX,y,CLASSES[i],{large:true,rightPad:40}));

      // layer labels (placed above layers, centered)
      addLayerLabel(inputX, marginTop - 50, 'Input', {center:true});
      addLayerLabel(h1X, marginTop - 50, 'Hidden 1', {center:true});
      addLayerLabel(h2X, marginTop - 50, 'Hidden 2', {center:true});
      addLayerLabel(h3X, marginTop - 50, 'Hidden 3', {center:true});
      addLayerLabel(outX, marginTop - 50, 'Output', {center:true});

      // connect layers
      inputYs.forEach(y1=> h1Ys.forEach(y2=> addLine(inputX+nodeR,y1,h1X-nodeR,y2)));
      h1Ys.forEach(y1=> h2Ys.forEach(y2=> addLine(h1X+nodeR,y1,h2X-nodeR,y2)));
      h2Ys.forEach(y1=> h3Ys.forEach(y2=> addLine(h2X+nodeR,y1,h3X-nodeR,y2, {thick:true})));
      h3Ys.forEach(y1=> outYs.forEach(y2=> addLine(h3X+nodeR,y1,outX-nodeR,y2)));

      // bias nodes (value=1) feeding each layer (visualized as a small constant node)
      const avg = arr => arr.reduce((a,b)=>a+b,0)/arr.length;
      // place bias nodes above each layer (near top) and connect with dashed lines
      const biasY = marginTop - 30;
      const biasToH1 = addBias(h1X-60, biasY, 'bias → H1');
      const biasToH2 = addBias(h2X-60, biasY, 'bias → H2');
      const biasToH3 = addBias(h3X-60, biasY, 'bias → H3');
      const biasToOut = addBias(outX-60, biasY, 'bias → OUT');

      // dashed connections from bias nodes to each neuron in their target layer
      h1Ys.forEach(y=> addLine(biasToH1.x, biasToH1.y + 6, h1X - nodeR - 4, y, {dashed:true}));
      h2Ys.forEach(y=> addLine(biasToH2.x, biasToH2.y + 6, h2X - nodeR - 4, y, {dashed:true}));
      h3Ys.forEach(y=> addLine(biasToH3.x, biasToH3.y + 6, h3X - nodeR - 4, y, {dashed:true}));
      outYs.forEach(y=> addLine(biasToOut.x, biasToOut.y + 6, outX - nodeR - 4, y, {dashed:true}));
    })();

  </script>
</body>
</html>
